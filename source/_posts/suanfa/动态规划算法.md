---
title: 动态规划算法
date: 2020-04-07 21:55:14
tags: [算法]
categories: [算法]
---

### 动态规划算法

​	 一般满足以下条件之一，大概率就是 **动态规划** 题目

  * 求最大值，最小值
  * 判断方案是否可行
  * 统计方案个数

#### 动态规划问题性质

	* 重叠子问题
	* 

#### 动态规划固定流程

	* 递归的暴力解法
	* 带备忘录的递归解法
	* 非递归的动态规划解法

#### 案例1：斐波那契数列

数列：0、1、1、2、3、5、8、13、21、34、...、n-2、n-1、n-2+n-1

 1. 暴力的递归算法

    **递归算法的时间复杂度**

    子问题个数乘以解决一个子问题需要的时间

    ```
    function fib(n) {
      if(n <= 0) return 0
      if(n <= 2) return 1
      return fib(n - 1) + fib(n - 2)
    }
    ```

    * 递归树

    ![斐波那契](./img/斐波那契-递归.png)

     * **递归算法的时间复杂度** ----- 子问题个数乘以解决一个子问题需要的时间
       1. 子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 **O(2^n)**
       2. 解决一个子问题的时间，在本算法中，没有循环，只有 f(n-1) + f(n-2) 一个加法操作，时间为**O(1)**
       3. 所以这个算法的时间复杂度为 **O(2^n)，指数级别

	2. 带备忘录的递归解法

    造一个备忘录，每次算出某个子问题的答案后先记到 备忘录 里再返回，每个遇到一个子问题先去 备忘录 里查一查

    ```
    function fib2(n) {
      if(n < 1) return 0
      let arr = new Array(n + 1)
      return helper(arr,n)
    }
    function helper(arr,n) {
      if(n <= 2) return 1
      if(arr[n]) return arr[n]
      arr[n] = helper(arr, n - 1) + helper(arr, n - 2)
      return arr[n]
    }
    ```

    * 递归树

      ![斐波那契](./img/斐波那契-备忘录递归.png)

    * **时间复杂度**

      1. 子问题个数，由于本算法中不存在冗余计算，子问题就是f(1),f(2),f(3)...f(n),数量和输入规模成正比，所以子问题个数为**O(n)**
      2. 解决一个子问题的时间，没有循环，时间为**O(1)
      3. 所以本算法的时间复杂度是**O(n)

    * 带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做【自顶向下】，动态规划叫做【自底向上】

      1. 【自顶向下】是从上向下延伸，都是从一个规模较大的原问题比如说 f(20),向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案
      2. 【自底向上】直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20),这就是动态规划的思路，所以动态规划一般脱离了递归，由循环迭代完成计算

	3. 动态规划

    ```
    function fib3(n) {
      let arr = new Array(n + 1)
      arr[0] = 0
      arr[1] = arr[2] = 1
      for(let i = 3; i <= n; i++){
        arr[i] = arr[i-1] + arr[i-2]
      }
      return arr[n]
    }
    ```

    * 树

      ![斐波那契-动态规划](./img/斐波那契-动态规划.png)

    * **动态转移方程--暴力解**

      把 f(n) 想做一个状态 n,这个状态 n 是由状态 n-1 和状态 n-2 相加转移而来，这就叫状态转移

	4. 动态规划优化

    当前状态只和之前的两个状态有关，所以不需要那么长的arr 来存储所有状态，只要想办法存储之前的两个状态就行了，所以可以进一步优化，把空间复杂度降为  **O(1)**

    ```
    function fib4(n) {
      if(n < 2) return n
      let pre = 0
      let cur = 1
      for(let i = 0; i < n - 1; i++){
        let sum = pre + cur
        pre = cur
        cur = sum
      }
      return cur
    }
    ```

    

#### 案例2：凑零钱问题

题目：给你 k 种面值的硬币，面值分为 c1,c2,...ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1

比如，，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。

​	这个时候我们分别假设 1，2，5 三种面值的币分别为最后一个硬币的情况：

- 最后一枚硬币的面额为 1: min = f(11-1) + 1

- 最后一枚硬币的面额为 2: min = f(11-2) + 1

- 最后一枚硬币的面额为 5: min = f(11-5) + 1

  f(11) = min( f(11-1),f(11-2),f(11-5) ) + 1

  * f(n) = min{f(n-1), f(n-5), f(n-11)} + 1
  * f(n-1) = min{f(n-1-1), f(n-1-5), f(n-1-11)} + 1

 1. 暴力解法-递归

    * **最优子结构**，子问题间必须互相独立

    ```
    function coin(coins, amount) {
      if(amount === 0) return 0
      let min = Number.MAX_SAFE_INTEGER
      for(let i of coins){
        if(amount - i < 0) continue
        min = Math.min(coin(coins,amount - i),min)
      }
      return min + 1
    }
    ```

    * 递归树

      ![凑零钱-递归](./img/凑零钱-递归.png)

    * 时间复杂度

      1. 子问题总数，**O(n^k)**
      2. 每个子问题中含有一个for循环，复杂度为 **O(k)**
      3. 所以总时间复杂度为 **O(k*n^k)**

	2. 带备忘录的递归算法

    ```
    function coin2(coins, amount) {
      let arr = new Array(amount + 1)
      return coinHelper(coins, amount,arr)
    }
    function coinHelper(coins, amount,arr) {
      if(amount === 0) return 0
      if(arr[amount]) return arr[amount]
      let min = Number.MAX_SAFE_INTEGER
      for(let i of coins){
        if(amount - i < 0) continue
        min = Math.min(coinHelper(coins, amount-i,arr),min)
      }
      arr[amount] = min + 1
      return arr[amount]
    }
    ```

	3. 动态规划

    ```
    function coin3(coins, amount) {
      let arr = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER)
      arr[0] = 0
      for(let i = 1; i <= amount; i++){
        for(let j of coins){
          if(i < j) continue
          arr[i] = Math.min(arr[i-j],arr[i])+1
        }
      }
      return arr[amount]
    }
    ```

    * 树

      ![凑零钱-动态规划](./img/凑零钱-动态规划.png)



#### 案例3：双蛋问题

![双蛋问题](./img/双蛋.png)

1. 递归解法

   假设从 i 层开始扔鸡蛋

   f(还要尝试的楼层，剩下的鸡蛋)

   	* 鸡蛋碎了 f(i-1,e-1) 
   	* 鸡蛋没碎 f(f-i,e)
   	* max(f(i-1,e-1),  f(f-i,e)) + 1

   ```
   function egg(f,e) {
     if(f <= 1 || e === 1) return f
     let min = Number.MAX_SAFE_INTEGER
     for(let i = 1; i <= f; i++){
       min = Math.min(Math.max(egg(i-1,e-1),egg(f-i,e))+1,min)
     }
     return min
   }
   ```

   * 递归树

     ![img](./img/双蛋树.png)

2. 动态规划

   ![img](./img/双蛋-动态规划.png)

   ```
   function egg2(f,e) {
     if(f <= 1 || e === 1) return f
     // 二维数组,初始填充0
     let arr = Array.from(new Array(f+1), () => new Array(e + 1).fill(0))
     // 边界处理，只有一个鸡蛋，i 层就要扔 i 次
     for(let i = 1; i <= f; i++){
       arr[i][1] = i
     }
     // 边界处理，只有一层，i不论多少个鸡蛋，只要扔一次
     for(let j = 1; j <= e; j++){
       arr[1][j] = 1
     }
     for(let i = 2; i <= f; i++){
       for(let j = 2; j <= e; j++){
         let min = Number.MAX_SAFE_INTEGER
         for(let k = 1; k < i; k++){
           min = Math.min(Math.max(arr[k-1][j-1],arr[i-k][j])+1,min)
         }
         arr[i][j] = min
       }
     }
     return arr[f][e]
   }
   ```

   

#### 案例4：石头游戏

题目：你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。

石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 piles = [1, 100, 3]，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。

假设两人都很聪明，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。

这样推广之后，这个问题算是一道 Hard 的动态规划问题了。博弈问题的难点在于，两个人要轮流进行选择，而且都贼精明，应该如何编程表示这个过程呢？

还是强调多次的套路，首先明确 dp 数组的含义，然后和股票买卖系列问题类似，只要找到「状态」和「选择」，一切就水到渠成了。

##### 一、定义 dp 数组的含义

定义 dp 数组的含义是很有技术含量的，同一问题可能有多种定义方法，不同的定义会引出不同的状态转移方程，不过只要逻辑没有问题，最终都能得到相同的答案。

介绍 dp 数组的含义之前，我们先看一下 dp 数组最终的样子：



![img](./img/石头-1.png)



下文讲解时，认为元组是包含 first 和 second 属性的一个类，而且为了节省篇幅，将这两个属性简写为 fir 和 sec。比如按上图的数据，我们说 ```dp[1][3].fir = 10，dp[0][1].sec = 3```。

先回答几个读者可能提出的问题：

这个二维 dp table 中存储的是元组，怎么编程表示呢？这个 dp table 有一半根本没用上，怎么优化？很简单，都不要管，先把解题的思路想明白了再谈也不迟。

**以下是对 dp 数组含义的解释：**

```
dp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。
dp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。

举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始
dp[0][1].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。
dp[1][3].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。
复制代码
```

我们想求的答案是先手和后手最终分数之差，按照这个定义也就是 ```dp[0][n-1].fir - dp[0][n-1].sec```，即面对整个 piles，先手的最优得分和后手的最优得分之差。

##### 二、状态转移方程

写状态转移方程很简单，首先要找到所有「状态」和每个状态可以做的「选择」，然后择优。

根据前面对 dp 数组的定义，**状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的人。**

```
dp[i][j][fir or sec]
其中：
0 <= i < piles.length
i <= j < piles.length
```

对于这个问题的每个状态，可以做的选择有两个：选择最左边的那堆石头，或者选择最右边的那堆石头。 我们可以这样穷举所有状态：

```
n = piles.length
for 0 <= i < n:
    for j <= i < n:
        for who in {fir, sec}:
            dp[i][j][who] = max(left, right)
```

上面的伪码是动态规划的一个大致的框架，股票系列问题中也有类似的伪码。这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？

根据我们对 dp 数组的定义，很容易解决这个难点，**写出状态转移方程：**

```
dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)
dp[i][j].fir = max(选择最左边的石头堆, 选择最右边的石头堆)
 # 解释：我作为先手，面对 piles[i...j] 时，有两种选择：
 # 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]
 # 但是此时轮到对方，相当于我变成了后手；
 # 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]
 # 但是此时轮到对方，相当于我变成了后手。

if 先手选择左边:
dp[i][j].sec = dp[i+1][j].fir
if 先手选择右边:
dp[i][j].sec = dp[i][j-1].fir
# 解释：我作为后手，要等先手先选择，有两种情况：
# 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]
# 此时轮到我，我变成了先手；
# 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]
# 此时轮到我，我变成了先手。
复制代码
```

根据 dp 数组的定义，我们也可以找出 base case，也就是最简单的情况：

```
dp[i][j].fir = piles[i]
dp[i][j].sec = 0
其中 0 <= i == j < n
# 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]
# 那么显然先手的得分为 piles[i]
# 后手没有石头拿了，得分为 0
复制代码
```



![img](./img/石头-2.png)



这里需要注意一点，我们发现 base case 是斜着的，而且我们推算 dp[i][j] 时需要用到 ```dp[i+1][j] 和 dp[i][j-1]：```



![img](./img/石头-3.png)



所以说算法不能简单的一行一行遍历 dp 数组，而要**斜着遍历数组：**



![img](./img/石头-4.png)



说实话，斜着遍历二维数组说起来容易，你还真不一定能想出来怎么实现，不信你思考一下？这么巧妙的状态转移方程都列出来了，要是不会写代码实现，那真的很尴尬了。。。

##### 三、代码实现

如何实现这个 fir 和 sec 元组呢，你可以用 python，自带元组类型；或者使用 C++ 的 pair 容器；或者用一个三维数组 ```dp[n][n][2]```，最后一个维度就相当于元组；或者我们自己写一个 Pair 类：

```
class Pair {
    int fir, sec;
    Pair(int fir, int sec) {
        this.fir = fir;
        this.sec = sec;
    }
}
复制代码
```

然后直接把我们的状态转移方程翻译成代码即可，可以注意一下斜着遍历数组的技巧：

```
/* 返回游戏最后先手和后手的得分之差 */
int stoneGame(int[] piles) {
    int n = piles.length;
    // 初始化 dp 数组
    Pair[][] dp = new Pair[n][n];
    for (int i = 0; i < n; i++) 
        for (int j = i; j < n; j++)
            dp[i][j] = new Pair(0, 0);
    // 填入 base case
    for (int i = 0; i < n; i++) {
        dp[i][i].fir = piles[i];
        dp[i][i].sec = 0;
    }
    // 斜着遍历数组
    for (int l = 2; l <= n; l++) {
        for (int i = 0; i <= n - l; i++) {
            int j = l + i - 1;
            // 先手选择最左边或最右边的分数
            int left = piles[i] + dp[i+1][j].sec;
            int right = piles[j] + dp[i][j-1].sec;
            // 套用状态转移方程
            if (left > right) {
                dp[i][j].fir = left;
                dp[i][j].sec = dp[i+1][j].fir;
            } else {
                dp[i][j].fir = right;
                dp[i][j].sec = dp[i][j-1].fir;
            }
        }
    }
    Pair res = dp[0][n-1];
    return res.fir - res.sec;
}
复制代码
```

动态规划解法，如果没有状态转移方程指导，绝对是一头雾水，但是根据前面的详细解释，读者应该可以清晰理解这一大段代码的含义。

而且，注意到计算 ```dp[i][j] ```只依赖其左边和下边的元素，所以说肯定有优化空间，转换成一维 dp，想象一下把二维平面压扁，也就是投影到一维。但是，一维 dp 比较复杂，可解释性很差，大家就不必浪费这个时间去理解了。

##### 四、最后总结

本文给出了解决博弈问题的动态规划解法。博弈问题的前提一般都是在两个聪明人之间进行，编程描述这种游戏的一般方法是二维 dp 数组，数组中通过元组分别表示两人的最优决策。

之所以这样设计，是因为先手在做出选择之后，就成了后手，后手在对方做完选择后，就变成了先手。这种角色转换使得我们可以重用之前的结果，典型的动态规划标志。

读到这里的朋友应该能理解算法解决博弈问题的套路了。学习算法，一定要注重算法的模板框架，而不是一些看起来牛逼的思路，也不要奢求上来就写一个最优的解法。不要舍不得多用空间，不要过早尝试优化，不要惧怕多维数组。dp 数组就是存储信息避免重复计算的，随便用，直到咱满意为止。

##### 3. 动态规划设计方法：归纳思想

了解了动态规划的套路，也不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：数学归纳思想。

最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何写动态规划。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。

先看一下题目，很容易理解：



![img](./img/最长递增子序列.png)



注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来一步一步设计动态规划算法解决这个问题。

**动态规划解法** 动态规划的核心设计思想是**数学归纳法**。

相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 k<nk<n 时成立，然后想办法证明 k=nk=n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。

类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 dp[0...i-1]dp[0...i−1] 都已经被算出来了，然后问自己：怎么通过这些结果算出 dp[i]？

直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？

**我们的定义是这样的：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。**

举两个例子：



![img](./img/最长递增子序列2.png)



算法演进的过程是这样的，：



![img](./img/最长递增子序列3.png)



根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。

```
int res = 0;
for (int i = 0; i < dp.size(); i++) {
    res = Math.max(res, dp[i]);
}
return res;
```

读者也许会问，刚才这个过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？

这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：

我们已经知道了 dp[0...4]dp[0...4] 的所有结果，我们如何通过这些已知结果推出 dp[5]dp[5] 呢？

根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。

nums[5] = 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。

当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。



![img](./img/最长递增子序列3)



```
for (int j = 0; j < i; j++) {
    if (nums[i] > nums[j]) 
        dp[i] = Math.max(dp[i], dp[j] + 1);
}
```

这段代码的逻辑就可以算出 dp[5]。到这里，这道算法题我们就基本做完了。读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？

类似数学归纳法，你已经可以算出 dp[5] 了，其他的就都可以算出来：

```
for (int i = 0; i < nums.length; i++) {
    for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) 
            dp[i] = Math.max(dp[i], dp[j] + 1);
    }
}
复制代码
```

还有一个细节问题，dp 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最小为 1。下面我们看一下完整代码：

```
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    // dp 数组全都初始化为 1
    Arrays.fill(dp, 1);
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) 
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
    
    int res = 0;
    for (int i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
复制代码
```

至此，这道题就解决了，时间复杂度 O(N^2)。总结一下动态规划的**设计流程：**

**首先明确 dp 数组所存数据的含义**。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

**然后根据 dp 数组的定义，运用数学归纳法的思想**，假设 dp[0...i-1]dp[0...i−1] 都已知，想办法求出 dp[i]dp[i]，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。

**最后想一想问题的 base case 是什么，以此来初始化 dp 数组**,以保证算法正确运行。

